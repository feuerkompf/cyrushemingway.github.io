<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
		<title>3D Game Design</title>
		<script src="cannon.js"></script>
		<script src="babylon.js"></script>
		<script src="babylon.objFileLoader.min.js"></script>
		<style>
			html, body {
				overflow: hidden;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}
			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
			}
		</style>

		<script>
			function start() {

				var canvas = document.getElementById('renderCanvas');
				var engine = new BABYLON.Engine(canvas, true);

				var keys = {};
				window.addEventListener('keydown', function(e) {
					keys[e.key] = true;
				});

				window.addEventListener('keyup', function(e) {
					keys[e.key] = false;
				});

				var scene = new BABYLON.Scene(engine);

				var gravityVector = new BABYLON.Vector3(0, -9.81, 0);
				scene.enablePhysics(gravityVector, new BABYLON.CannonJSPlugin());

				scene.clearColor = new BABYLON.Color3(0.5, 0.8, 0.5);

				//===TRACK CODE # 1 ===//

				var _xFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.025)+(3*t*Math.pow((1-t),2)*0.1)+(3*Math.pow(t,2)*(1-t)*0.1625)+(Math.pow(t,3)*0.225)}];var i = Math.max(0,Math.min(0, Math.floor(t * 1)));return fns[i]((t - (i/1)) * 1);};
				var _yFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.2)+(3*t*Math.pow((1-t),2)*0.025)+(3*Math.pow(t,2)*(1-t)*0.025)+(Math.pow(t,3)*0.2)}];var i = Math.max(0,Math.min(0, Math.floor(t * 1)));return fns[i]((t - (i/1)) * 1);};
				/* START CURVE DATA 
				{"start":[10,80],"init":[40,10],"segments":[{"a":[65,10],"b":[90,80]}]}
				   END CURVE DATA */

				//===END TRACK CODE # 1 ===//
				//===TRACK CODE # 2 ===//

				// var _xFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.4775)+(3*t*Math.pow((1-t),2)*0.155)+(3*Math.pow(t,2)*(1-t)*0.74)+(Math.pow(t,3)*0.7125)},function(t) {return (Math.pow((1-t),3)*0.7125)+(3*t*Math.pow((1-t),2)*0.685)+(3*Math.pow(t,2)*(1-t)*0.1775)+(Math.pow(t,3)*0.445)},function(t) {return (Math.pow((1-t),3)*0.445)+(3*t*Math.pow((1-t),2)*0.7125)+(3*Math.pow(t,2)*(1-t)*0.025)+(Math.pow(t,3)*0.1725)},function(t) {return (Math.pow((1-t),3)*0.1725)+(3*t*Math.pow((1-t),2)*0.32)+(3*Math.pow(t,2)*(1-t)*0.975)+(Math.pow(t,3)*0.13)},function(t) {return (Math.pow((1-t),3)*0.13)+(3*t*Math.pow((1-t),2)*-0.715)+(3*Math.pow(t,2)*(1-t)*0.2925)+(Math.pow(t,3)*0.2925)},function(t) {return (Math.pow((1-t),3)*0.2925)+(3*t*Math.pow((1-t),2)*0.2925)+(3*Math.pow(t,2)*(1-t)*0.3675)+(Math.pow(t,3)*0.4775)}];var i = Math.max(0,Math.min(5, Math.floor(t * 6)));return fns[i]((t - (i/6)) * 6);};
				// var _yFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.1578125)+(3*t*Math.pow((1-t),2)*0.7703125)+(3*Math.pow(t,2)*(1-t)*0.2003125)+(Math.pow(t,3)*0.6328125)},function(t) {return (Math.pow((1-t),3)*0.6328125)+(3*t*Math.pow((1-t),2)*1.0653125)+(3*Math.pow(t,2)*(1-t)*0.9628125)+(Math.pow(t,3)*0.7578125)},function(t) {return (Math.pow((1-t),3)*0.7578125)+(3*t*Math.pow((1-t),2)*0.5528125)+(3*Math.pow(t,2)*(1-t)*0.7478125)+(Math.pow(t,3)*0.3078125)},function(t) {return (Math.pow((1-t),3)*0.3078125)+(3*t*Math.pow((1-t),2)*-0.1321875)+(3*Math.pow(t,2)*(1-t)*0.1803125)+(Math.pow(t,3)*0.0928125)},function(t) {return (Math.pow((1-t),3)*0.0928125)+(3*t*Math.pow((1-t),2)*0.0053125)+(3*Math.pow(t,2)*(1-t)*0.2278125)+(Math.pow(t,3)*0.2278125)},function(t) {return (Math.pow((1-t),3)*0.2278125)+(3*t*Math.pow((1-t),2)*0.2278125)+(3*Math.pow(t,2)*(1-t)*0.1903125)+(Math.pow(t,3)*0.1578125)}];var i = Math.max(0,Math.min(5, Math.floor(t * 6)));return fns[i]((t - (i/6)) * 6);};
			/* START CURVE DATA 
			{"start":[191,63.125],"init":[62,308.125],"segments":[{"a":[296,80.125],"b":[285,253.125]},{"a":[71,385.125],"b":[178,303.125]},{"a":[10,299.125],"b":[69,123.125]},{"a":[390,72.125],"b":[52,37.125]},{"a":[117,91.125],"b":[117,91.125]},{"a":[147,76.125],"b":[191,63.125]}]}
			   END CURVE DATA */

				//===END TRACK CODE # 2 ===//
				//===TRACK CODE # 3 ===//

					// var _xFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.0825)+(3*t*Math.pow((1-t),2)*0.22)+(3*Math.pow(t,2)*(1-t)*0.7125)+(Math.pow(t,3)*0.835)},function(t) {return (Math.pow((1-t),3)*0.835)+(3*t*Math.pow((1-t),2)*0.9575)+(3*Math.pow(t,2)*(1-t)*0.7475)+(Math.pow(t,3)*0.7475)},function(t) {return (Math.pow((1-t),3)*0.7475)+(3*t*Math.pow((1-t),2)*0.7475)+(3*Math.pow(t,2)*(1-t)*0.2575)+(Math.pow(t,3)*0.145)},function(t) {return (Math.pow((1-t),3)*0.145)+(3*t*Math.pow((1-t),2)*0.0325)+(3*Math.pow(t,2)*(1-t)*0.035)+(Math.pow(t,3)*0.0825)}];var i = Math.max(0,Math.min(3, Math.floor(t * 4)));return fns[i]((t - (i/4)) * 4);};
					// var _yFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.2028125)+(3*t*Math.pow((1-t),2)*0.0103125)+(3*Math.pow(t,2)*(1-t)*0.0153125)+(Math.pow(t,3)*0.1978125)},function(t) {return (Math.pow((1-t),3)*0.1978125)+(3*t*Math.pow((1-t),2)*0.3803125)+(3*Math.pow(t,2)*(1-t)*0.8203125)+(Math.pow(t,3)*0.8203125)},function(t) {return (Math.pow((1-t),3)*0.8203125)+(3*t*Math.pow((1-t),2)*0.8203125)+(3*Math.pow(t,2)*(1-t)*0.9728125)+(Math.pow(t,3)*0.8403125)},function(t) {return (Math.pow((1-t),3)*0.8403125)+(3*t*Math.pow((1-t),2)*0.7078125)+(3*Math.pow(t,2)*(1-t)*0.3878125)+(Math.pow(t,3)*0.2028125)}];var i = Math.max(0,Math.min(3, Math.floor(t * 4)));return fns[i]((t - (i/4)) * 4);};
			/* START CURVE DATA 
			{"start":[33,81.125],"init":[88,4.125],"segments":[{"a":[285,6.125],"b":[334,79.125]},{"a":[299,328.125],"b":[299,328.125]},{"a":[103,389.125],"b":[58,336.125]},{"a":[14,155.125],"b":[33,81.125]}]}
			   END CURVE DATA */

				//===END TRACK CODE # 3 ===//
				//===TRACK CODE # 4 ===//

				// var _xFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.025)+(3*t*Math.pow((1-t),2)*0.0025)+(3*Math.pow(t,2)*(1-t)*0.1575)+(Math.pow(t,3)*0.1375)},function(t) {return (Math.pow((1-t),3)*0.1375)+(3*t*Math.pow((1-t),2)*0.1175)+(3*Math.pow(t,2)*(1-t)*0.12)+(Math.pow(t,3)*0.7725)}];var i = Math.max(0,Math.min(1, Math.floor(t * 2)));return fns[i]((t - (i/2)) * 2);};
				// var _yFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.2)+(3*t*Math.pow((1-t),2)*0.0028125)+(3*Math.pow(t,2)*(1-t)*0.1078125)+(Math.pow(t,3)*0.6303125)},function(t) {return (Math.pow((1-t),3)*0.6303125)+(3*t*Math.pow((1-t),2)*1.1528125)+(3*Math.pow(t,2)*(1-t)*0.3628125)+(Math.pow(t,3)*0.3253125)}];var i = Math.max(0,Math.min(1, Math.floor(t * 2)));return fns[i]((t - (i/2)) * 2);};
			/* START CURVE DATA 
			{"start":[33,81.125],"init":[88,4.125],"segments":[{"a":[285,6.125],"b":[334,79.125]},{"a":[299,328.125],"b":[299,328.125]},{"a":[103,389.125],"b":[58,336.125]},{"a":[14,155.125],"b":[33,81.125]}]}
			   END CURVE DATA */

				//===END TRACK CODE # 4 ===//
				//===TRACK CODE Jump ===//

				// var _xFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.5975)+(3*t*Math.pow((1-t),2)*0.2225)+(3*Math.pow(t,2)*(1-t)*0.71)+(Math.pow(t,3)*0.715)},function(t) {return (Math.pow((1-t),3)*0.715)+(3*t*Math.pow((1-t),2)*0.72)+(3*Math.pow(t,2)*(1-t)*0.015)+(Math.pow(t,3)*0.3025)}];var i = Math.max(0,Math.min(1, Math.floor(t * 2)));return fns[i]((t - (i/2)) * 2);};
				// var _yFn = function(t) {var fns = [function(t) {return (Math.pow((1-t),3)*0.2453125)+(3*t*Math.pow((1-t),2)*0.1903125)+(3*Math.pow(t,2)*(1-t)*0.1978125)+(Math.pow(t,3)*0.7778125)},function(t) {return (Math.pow((1-t),3)*0.7778125)+(3*t*Math.pow((1-t),2)*1.3578125)+(3*Math.pow(t,2)*(1-t)*0.5453125)+(Math.pow(t,3)*0.2178125)}];var i = Math.max(0,Math.min(1, Math.floor(t * 2)));return fns[i]((t - (i/2)) * 2);};
			/* START CURVE DATA 
			{"start":[33,81.125],"init":[88,4.125],"segments":[{"a":[285,6.125],"b":[334,79.125]},{"a":[299,328.125],"b":[299,328.125]},{"a":[103,389.125],"b":[58,336.125]},{"a":[14,155.125],"b":[33,81.125]}]}
			   END CURVE DATA */

				//===END TRACK CODE Jump ===//

				var xFn = function(t) { return 650 * _xFn(t); }
				var zFn = function(t) { return 650 * _yFn(t); }

				var playerSphere = BABYLON.MeshBuilder.CreateSphere("playerSphere", {
					segments: 12,
					diameter: 4
				}, scene);
				playerSphere.material = new BABYLON.StandardMaterial("playerSphereMaterial", scene);
				playerSphere.material.diffuseTexture = new BABYLON.Texture('resources/BeachBallColor.jpg', scene);
				playerSphere.position = new BABYLON.Vector3(xFn(0), 9, zFn(0));
				playerSphere.physicsImpostor = new BABYLON.PhysicsImpostor(playerSphere, BABYLON.PhysicsImpostor.SphereImpostor, {
						mass: 1,
						restitution: 0.9
					}, scene);

				var camera = new BABYLON.ArcRotateCamera("Camera", 0, (3 * Math.PI) / 8, 20, playerSphere, scene);
				camera.attachControl(canvas, true);

				var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);

				rampAt(xFn, zFn, 0.07, -Math.PI / 4, scene);

				wallAt(xFn, zFn, 0.55, -6.1, scene);

				wallAt(xFn, zFn, 0.45, -6.1, scene);

				wallAt(xFn, zFn, 0.58, -6.1, scene);

				wallAt(xFn, zFn, 0.95, -6.1, scene);

				wallAt(xFn, zFn, 0.9, -6.1, scene);

				wallAt(xFn, zFn, 0.85, -6.1, scene);

				scene.registerAfterRender(function() {
					var vel = playerSphere.physicsImpostor.getLinearVelocity();
					playerSphere.physicsImpostor.setLinearVelocity(vel.scale(.98));

				BABYLON.SceneLoader.ImportMesh(null, "resources/", "speed.obj", scene, function(meshes) {
					var boostMesh = meshes[0], boosts = [];
					boostMesh.material = new BABYLON.StandardMaterial("boostMaterial", scene);
					boostMesh.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
					boostMesh.scaling = new BABYLON.Vector3(5, 5, 5);
					boostMesh.setEnabled(false);
					function boostAt(xFn, zFn, t) {
						var newBoost = boostMesh.clone('boost');
						newBoost.position = new BABYLON.Vector3(xFn(t), 3.2, zFn(t));
						newBoost.rotation.y = -derivAngle(t, xFn, zFn);
						newBoost.setEnabled(true);
						boosts.push(newBoost);
					}

				// Place boosts here
					boostAt(xFn, zFn, 0.05);

					scene.registerAfterRender(function() {
						boosts.forEach(function(boost, i){
							if(boost.intersectsMesh(playerSphere)){
								boost.dispose();
								boosts.splice(i,1);
								var vel = playerSphere.physicsImpostor.getLinearVelocity();
								playerSphere.applyImpulse(vel.normalize().scale(100), playerSphere.getAbsolutePosition());
							} else {
								boost.rotation.y += 0.01
							}
						});
					});
				});

					var forward = camera.getFrontPosition(1).subtract(camera.position);
					forward.y = 0;
					forward = forward.normalize().scale(1);

					var backward = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY(Math.PI));

					var left = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY((3 * Math.PI) / 2));

					var right = BABYLON.Vector3.TransformCoordinates(forward, BABYLON.Matrix.RotationY(Math.PI / 2));

					if (keys.w) {
						playerSphere.applyImpulse(forward, playerSphere.getAbsolutePosition());
					}
					if (keys.s) {
						playerSphere.applyImpulse(backward, playerSphere.getAbsolutePosition());
					}
					if (keys.a) {
						playerSphere.applyImpulse(left, playerSphere.getAbsolutePosition());
					}
					if (keys.d) {
						playerSphere.applyImpulse(right, playerSphere.getAbsolutePosition());
					}

					var currentT = tLookup(xFn, zFn, 500, playerSphere.position.x, playerSphere.position.z);

					var angle = (derivAngle(currentT, xFn, zFn) - (Math.PI));
					camera.alpha += (angle - camera.alpha) / 32;

					if (currentT > 0.99) {
						win();
					}

					if (playerSphere.position.y < -10) {
						lost();
					}
				});

				function drawPoint(x, z, zrot, scene) {
					var point = BABYLON.MeshBuilder.CreateBox('point', {
						width: 10,
						height: 0.5,
						depth: 12
					}, scene);
					point.material = new BABYLON.StandardMaterial("pointMaterial", scene);
					point.material.diffuseColor = new BABYLON.Color3(1, 0, 1);
					point.position = new BABYLON.Vector3(x, 0.1, z);
					point.rotation.y = zrot;
					point.physicsImpostor = new BABYLON.PhysicsImpostor(point, BABYLON.PhysicsImpostor.BoxImpostor, {
							mass: 0,
							restitution: 0.9
						}, scene);
				}

				function drawParametric(xFn, zFn, start, end, res, scene) {
					for (var t = start; t <= end; t += ((end - start) / res)) {
						drawPoint(xFn(t), zFn(t), 0 , scene);
					}
				}

				drawParametric(xFn, zFn, 0, 1, 350, scene);

				function tLookup(xFn, zFn, res, x, z) {
					var minT = 0;
					var minDist = Infinity;
					for (var t = 0; t <= 1; t += (1 / res)) {
						var dist = Math.pow(x - xFn(t), 2) + Math.pow(z - zFn(t), 2);
						if (dist < minDist) {
							minDist = dist;
							minT = t;
						}
					}
					return minT;
				}

			function derivAngle(t, xFn, zFn) {
				function derive(f, x) {
					var h = 2.2e-10;
					return (f(x + h) - f(x - h)) / (2 * h);
				}
				return Math.atan2(derive(zFn, t), derive(xFn, t));
			}

			function rampAt(xFn, zFn, t, angle, scene) {
				var ramp = BABYLON.MeshBuilder.CreateBox('ramp', {
					height: 8,
					width: .25,
					depth: 12
			}, scene);
			ramp.material = new BABYLON.StandardMaterial("rampMaterial", scene);
			ramp.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
			ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, {
				mass: 0,
				restitution: 0.9
			}, scene);
			ramp.position = new BABYLON.Vector3(xFn(t), 3.3, zFn(t));

			ramp.rotation.z = angle;
			ramp.rotation.y = -derivAngle(t, xFn, zFn);
			}

			function wallAt(xFn, zFn, t, offset, scene) {
				var wall = BABYLON.MeshBuilder.CreateBox('wall', {
					height: 8,
					width: .25,
					depth: 12
				}, scene);
				angle = -derivAngle(t, xFn, zFn);
				wall.material = new BABYLON.StandardMaterial("wallMaterial", scene);
				wall.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
				wall.physicsImpostor = new BABYLON.PhysicsImpostor(wall, BABYLON.PhysicsImpostor.BoxImpostor, {
					mass: 0,
					restitution: 0.9
				}, scene);
				wall.position = new BABYLON.Vector3(xFn(t) + (offset * Math.sin(angle)), 4, zFn(t) + (offset * Math.cos(angle)));
				wall.rotation.y = angle + (Math.PI / 2);
				return wall;
			}

				engine.runRenderLoop(scene.render.bind(scene));
				window.addEventListener('resize', engine.resize.bind(engine));
			}

			function win(){
				window.location.reload();
				alert("You WIN!");
			}

			function lost(){
				window.location.reload();
				alert("you lose!");
			}

		</script>
	</head>
	<body onload="start()">
		<canvas id="renderCanvas"></canvas>
	</body>
</html>